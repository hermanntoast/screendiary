<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation — ScreenDiary</title>
    <meta name="description" content="Complete documentation for ScreenDiary: installation, configuration, CLI reference, API reference, architecture, and troubleshooting.">
    <link rel="icon" href="img/favicon.png" type="image/png">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/docs.css">
</head>
<body>

<!-- Navbar -->
<nav class="navbar">
    <div class="container">
        <a href="index.html" class="navbar-brand">
            <img src="img/logo_white.png" alt="ScreenDiary">
            ScreenDiary
        </a>
        <ul class="navbar-links">
            <li><a href="index.html">Home</a></li>
            <li><a href="https://github.com/hermanntoast/screendiary" target="_blank">GitHub</a></li>
        </ul>
    </div>
</nav>

<!-- Hamburger (mobile) -->
<button class="hamburger" aria-label="Toggle sidebar">&#9776;</button>
<div class="sidebar-overlay"></div>

<!-- Sidebar -->
<aside class="sidebar">
    <div class="sidebar-group">
        <span class="sidebar-group-title">Getting Started</span>
        <a href="#requirements" class="sidebar-link">Requirements</a>
        <a href="#installation" class="sidebar-link">Installation</a>
        <a href="#quick-start" class="sidebar-link">Quick Start</a>
    </div>
    <div class="sidebar-group">
        <span class="sidebar-group-title">Configuration</span>
        <a href="#config-capture" class="sidebar-link">[capture]</a>
        <a href="#config-storage" class="sidebar-link">[storage]</a>
        <a href="#config-ocr" class="sidebar-link">[ocr]</a>
        <a href="#config-ai" class="sidebar-link">[ai]</a>
        <a href="#config-web" class="sidebar-link">[web]</a>
        <a href="#config-logging" class="sidebar-link">[logging]</a>
        <a href="#config-locations" class="sidebar-link">Config Locations</a>
    </div>
    <div class="sidebar-group">
        <span class="sidebar-group-title">Reference</span>
        <a href="#cli" class="sidebar-link">CLI Commands</a>
        <a href="#web-ui" class="sidebar-link">Web UI</a>
        <a href="#system-tray" class="sidebar-link">System Tray</a>
    </div>
    <div class="sidebar-group">
        <span class="sidebar-group-title">API Reference</span>
        <a href="#api-screenshots" class="sidebar-link">Screenshots</a>
        <a href="#api-timeline" class="sidebar-link">Timeline &amp; Dates</a>
        <a href="#api-search" class="sidebar-link">Search</a>
        <a href="#api-activity" class="sidebar-link">Activity</a>
        <a href="#api-system" class="sidebar-link">System</a>
        <a href="#api-images" class="sidebar-link">Images</a>
    </div>
    <div class="sidebar-group">
        <span class="sidebar-group-title">Architecture</span>
        <a href="#architecture" class="sidebar-link">Overview</a>
        <a href="#db-schema" class="sidebar-link">Database Schema</a>
        <a href="#capture-pipeline" class="sidebar-link">Capture Pipeline</a>
        <a href="#storage-archiving" class="sidebar-link">Storage &amp; Archiving</a>
    </div>
    <div class="sidebar-group">
        <span class="sidebar-group-title">Help</span>
        <a href="#troubleshooting" class="sidebar-link">Troubleshooting</a>
    </div>
</aside>

<!-- Content -->
<main class="docs-layout">
<div class="docs-content">

<h1>ScreenDiary Documentation</h1>
<p>Complete reference for installing, configuring, and using ScreenDiary.</p>

<!-- ============================================================ -->
<!-- GETTING STARTED -->
<!-- ============================================================ -->

<h2 id="requirements">Requirements</h2>

<p>ScreenDiary requires a Linux system with KDE Plasma 6 (Wayland) and the following dependencies.</p>
<p><strong>Note:</strong> ScreenDiary was developed and tested exclusively on Arch Linux (CachyOS) with KDE Plasma 6 on Wayland. Other distributions or desktop environments may require adjustments.</p>

<table>
    <thead>
        <tr><th>Package</th><th>Purpose</th><th>Install (Arch)</th></tr>
    </thead>
    <tbody>
        <tr><td><code>tesseract</code></td><td>OCR engine</td><td><code>pacman -S tesseract</code></td></tr>
        <tr><td><code>tesseract-data-eng</code></td><td>English OCR data</td><td><code>pacman -S tesseract-data-eng</code></td></tr>
        <tr><td><code>tesseract-data-deu</code></td><td>German OCR data</td><td><code>pacman -S tesseract-data-deu</code></td></tr>
        <tr><td><code>spectacle</code></td><td>KDE screenshot tool</td><td><code>pacman -S spectacle</code></td></tr>
        <tr><td><code>ffmpeg</code></td><td>Video encoding (H.265)</td><td><code>pacman -S ffmpeg</code></td></tr>
        <tr><td><code>libayatana-appindicator</code></td><td>System tray support</td><td><code>pacman -S libayatana-appindicator</code></td></tr>
        <tr><td><code>python-gobject</code></td><td>GObject bindings for tray</td><td><code>pacman -S python-gobject</code></td></tr>
        <tr><td><code>python 3.12+</code></td><td>Runtime</td><td><code>pacman -S python</code></td></tr>
        <tr><td><code>uv</code></td><td>Python package manager</td><td><code>pacman -S uv</code></td></tr>
        <tr><td><code>nodejs / npm</code></td><td>Frontend build</td><td><code>pacman -S nodejs npm</code></td></tr>
    </tbody>
</table>

<h2 id="installation">Installation</h2>

<pre><code># 1. Clone the repository
git clone https://github.com/hermanntoast/screendiary.git
cd screendiary

# 2. Install Python dependencies
uv sync

# 3. Copy example config and edit as needed
cp config.toml.example config.toml
nano config.toml

# 4. Build the frontend
uv run screendiary build

# 5. Install systemd user services
uv run screendiary install

# 6. Start all services
uv run screendiary start</code></pre>

<p>This installs three systemd user services:</p>
<ul>
    <li><code>screendiary-capture.service</code> — Screenshot capture daemon</li>
    <li><code>screendiary-web.service</code> — Web UI server (FastAPI)</li>
    <li><code>screendiary-tray.service</code> — System tray icon</li>
</ul>

<h2 id="quick-start">Quick Start</h2>

<p>After installation, open the web UI:</p>
<pre><code># Open in browser
xdg-open http://localhost:18787</code></pre>

<p>Or check status:</p>
<pre><code>uv run screendiary status</code></pre>

<p>View live logs:</p>
<pre><code>uv run screendiary logs</code></pre>

<!-- ============================================================ -->
<!-- CONFIGURATION -->
<!-- ============================================================ -->

<h2 id="config-capture">[capture]</h2>
<p>Controls screenshot capture behavior.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>interval</code></td><td>int</td><td><code>2</code></td><td>Capture interval in seconds (1–30)</td></tr>
        <tr><td><code>similarity_threshold</code></td><td>float</td><td><code>0.98</code></td><td>Structural similarity threshold for deduplication (0.0–1.0). Higher = more duplicates kept</td></tr>
        <tr><td><code>tool</code></td><td>str</td><td><code>"spectacle"</code></td><td>Screenshot capture tool (currently only <code>spectacle</code>)</td></tr>
    </tbody>
</table>

<h2 id="config-storage">[storage]</h2>
<p>Controls where and how screenshots are stored and archived.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>data_dir</code></td><td>str</td><td><code>"data"</code></td><td>Base data directory for screenshots, DB, and video segments</td></tr>
        <tr><td><code>format</code></td><td>str</td><td><code>"webp"</code></td><td>Screenshot image format</td></tr>
        <tr><td><code>quality</code></td><td>int</td><td><code>80</code></td><td>WebP compression quality (0–100)</td></tr>
        <tr><td><code>thumbnail_width</code></td><td>int</td><td><code>320</code></td><td>Thumbnail width in pixels</td></tr>
        <tr><td><code>max_storage_gb</code></td><td>int</td><td><code>200</code></td><td>Maximum total storage in GB before cleanup</td></tr>
        <tr><td><code>archive_after_minutes</code></td><td>int</td><td><code>10</code></td><td>Archive screenshots older than N minutes into video segments</td></tr>
        <tr><td><code>segment_duration_minutes</code></td><td>int</td><td><code>5</code></td><td>Duration of each H.265 video segment</td></tr>
        <tr><td><code>h265_crf</code></td><td>int</td><td><code>28</code></td><td>H.265 Constant Rate Factor (0–51, lower = better quality)</td></tr>
        <tr><td><code>h265_preset</code></td><td>str</td><td><code>"medium"</code></td><td>H.265 encoding preset (ultrafast, fast, medium, slow, veryslow)</td></tr>
        <tr><td><code>frame_cache_size</code></td><td>int</td><td><code>100</code></td><td>Number of decoded frames to keep in LRU cache</td></tr>
    </tbody>
</table>

<h2 id="config-ocr">[ocr]</h2>
<p>Controls Tesseract OCR processing.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>languages</code></td><td>str</td><td><code>"deu+eng"</code></td><td>Tesseract language codes (+ separated)</td></tr>
        <tr><td><code>psm</code></td><td>int</td><td><code>3</code></td><td>Page segmentation mode (0–13, see Tesseract docs)</td></tr>
        <tr><td><code>min_text_length</code></td><td>int</td><td><code>10</code></td><td>Minimum extracted text length to store</td></tr>
        <tr><td><code>workers</code></td><td>int</td><td><code>2</code></td><td>Number of parallel OCR worker processes</td></tr>
    </tbody>
</table>

<h2 id="config-ai">[ai]</h2>
<p>Controls AI-powered search and chat features. Requires an OpenAI-compatible API endpoint.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>api_base</code></td><td>str</td><td><code>"http://localhost:8000/v1"</code></td><td>OpenAI-compatible API base URL</td></tr>
        <tr><td><code>api_key</code></td><td>str</td><td><code>""</code></td><td>API key for authentication</td></tr>
        <tr><td><code>embedding_model</code></td><td>str</td><td><code>"text-embedding-3-small"</code></td><td>Model for generating text embeddings</td></tr>
        <tr><td><code>chat_model</code></td><td>str</td><td><code>"gpt-4"</code></td><td>Model for AI chat responses</td></tr>
        <tr><td><code>chunk_max_tokens</code></td><td>int</td><td><code>512</code></td><td>Maximum tokens per text chunk for embedding</td></tr>
        <tr><td><code>enabled</code></td><td>bool</td><td><code>true</code></td><td>Enable or disable AI features globally</td></tr>
    </tbody>
</table>

<h2 id="config-web">[web]</h2>
<p>Web UI server settings.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>host</code></td><td>str</td><td><code>"127.0.0.1"</code></td><td>Server bind address</td></tr>
        <tr><td><code>port</code></td><td>int</td><td><code>18787</code></td><td>Server port</td></tr>
        <tr><td><code>page_size</code></td><td>int</td><td><code>50</code></td><td>Default page size for API pagination</td></tr>
    </tbody>
</table>

<h2 id="config-logging">[logging]</h2>
<p>Logging verbosity.</p>
<table class="config-table">
    <thead>
        <tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>level</code></td><td>str</td><td><code>"INFO"</code></td><td>Log level: DEBUG, INFO, WARNING, ERROR</td></tr>
    </tbody>
</table>

<h2 id="config-locations">Config File Locations</h2>
<p>ScreenDiary searches for <code>config.toml</code> in the following order:</p>
<ol>
    <li><code>$SCREENDIARY_CONFIG</code> environment variable (explicit path)</li>
    <li><code>./config.toml</code> (current working directory)</li>
    <li><code>~/.config/screendiary/config.toml</code> (XDG user config)</li>
</ol>
<p>If no config file is found, default values are used. You can also pass a config path explicitly:</p>
<pre><code>uv run screendiary --config /path/to/config.toml capture</code></pre>

<!-- ============================================================ -->
<!-- CLI REFERENCE -->
<!-- ============================================================ -->

<h2 id="cli">CLI Commands</h2>
<p>All commands accept a global <code>--config, -c</code> flag to specify the config file path.</p>

<pre><code>uv run screendiary [--config PATH] &lt;command&gt;</code></pre>

<table>
    <thead>
        <tr><th>Command</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>capture</code></td><td>Start the capture daemon. Takes periodic screenshots, runs OCR, tracks windows, and archives to video.</td></tr>
        <tr><td><code>web</code></td><td>Start the web UI server (FastAPI + Uvicorn).</td></tr>
        <tr><td><code>tray</code></td><td>Start the system tray icon with pause/resume controls.</td></tr>
        <tr><td><code>status</code></td><td>Show daemon status: screenshot count, OCR results, embeddings, video segments, storage usage, and systemd service states.</td></tr>
        <tr><td><code>build</code></td><td>Build the React frontend (<code>npm install</code> + <code>npm run build</code>).</td></tr>
        <tr><td><code>install</code></td><td>Install systemd user services to <code>~/.config/systemd/user/</code>.</td></tr>
        <tr><td><code>start</code></td><td>Start all services via <code>screendiary.target</code>.</td></tr>
        <tr><td><code>stop</code></td><td>Stop all services via <code>screendiary.target</code>.</td></tr>
        <tr><td><code>logs</code></td><td>Show combined service logs from journalctl (capture, web, tray).</td></tr>
    </tbody>
</table>

<!-- ============================================================ -->
<!-- WEB UI -->
<!-- ============================================================ -->

<h2 id="web-ui">Web UI</h2>

<p>The web UI is available at <code>http://localhost:18787</code> and consists of four pages, navigable via the top navbar.</p>

<h3>AI Chat (Default)</h3>
<p>The default start page at <code>http://localhost:18787/#chat</code>. A ChatGPT-style interface to query your screen activity in natural language. Features:</p>
<ul>
    <li>Two-step AI query analysis: the AI first extracts time ranges and keywords from your question, then searches activity and OCR data, then answers with context</li>
    <li>Conversation history for follow-up questions</li>
    <li>Streaming responses (Server-Sent Events)</li>
    <li>Markdown rendering in assistant messages (code blocks, lists, links, tables)</li>
    <li>Understands natural language time references (e.g. "heute morgen", "gestern abend", "letzte Stunde")</li>
</ul>

<h3>Player</h3>
<p>Available at <code>http://localhost:18787/#player</code>. Browse screenshots by date with a timeline scrubber. Features:</p>
<ul>
    <li>Multi-monitor layout with per-monitor images</li>
    <li>Date picker and keyboard navigation (arrow keys)</li>
    <li>Full-text search with highlighted OCR word overlays</li>
    <li>Thumbnail timeline for quick navigation</li>
</ul>

<h3>Activity Dashboard</h3>
<p>Available at <code>http://localhost:18787/#activity</code>. Shows daily activity breakdown:</p>
<ul>
    <li>Visual timeline of active windows throughout the day</li>
    <li>Top applications by usage time</li>
    <li>Top window titles by duration</li>
    <li>Top browser domains visited</li>
    <li>Category breakdown (coding, browser, terminal, etc.)</li>
    <li>AI-generated Zeiterfassung (time tracking) with activity blocks</li>
    <li>Message of the Day integrated into the Zeiterfassung card</li>
</ul>

<h3>Storage Page</h3>
<p>Available at <code>http://localhost:18787/#storage</code>. View storage usage statistics:</p>
<ul>
    <li>Live vs. archived screenshot counts and database size</li>
    <li>Storage usage projection: GB/day, screenshots/day, estimated remaining days</li>
    <li>Forecast table for 7, 30, 90, and 365 days</li>
    <li>Color-coded capacity warnings</li>
</ul>

<!-- ============================================================ -->
<!-- SYSTEM TRAY -->
<!-- ============================================================ -->

<h2 id="system-tray">System Tray</h2>

<p>The tray icon provides quick access to capture controls without opening the web UI.</p>

<h3>Icon States</h3>
<table>
    <thead><tr><th>State</th><th>Appearance</th><th>Title</th></tr></thead>
    <tbody>
        <tr><td>Active</td><td>Dark gray with "SD" monogram</td><td>ScreenDiary</td></tr>
        <tr><td>Paused</td><td>Orange with "SD" monogram</td><td>ScreenDiary (pausiert)</td></tr>
    </tbody>
</table>

<h3>Menu Options</h3>
<p><strong>While active:</strong></p>
<ul>
    <li><strong>Aufnahme pausieren</strong> (Pause Recording) — submenu with durations: 5, 10, 30, 60 minutes, or indefinitely</li>
    <li><strong>WebUI öffnen</strong> — Opens the web UI in the default browser</li>
    <li><strong>Beenden</strong> — Quit the tray application</li>
</ul>
<p><strong>While paused:</strong></p>
<ul>
    <li><strong>Aufnahme fortsetzen</strong> (Resume Recording)</li>
    <li><strong>WebUI öffnen</strong></li>
    <li><strong>Beenden</strong></li>
</ul>

<h3>Signal Control</h3>
<p>The tray communicates with the capture daemon via systemd signals:</p>
<table>
    <thead><tr><th>Signal</th><th>Effect</th></tr></thead>
    <tbody>
        <tr><td><code>SIGUSR1</code></td><td>Pause capture</td></tr>
        <tr><td><code>SIGUSR2</code></td><td>Resume capture</td></tr>
    </tbody>
</table>

<!-- ============================================================ -->
<!-- API REFERENCE -->
<!-- ============================================================ -->

<h2 id="api-screenshots">API: Screenshots</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/screenshots</span>
    </div>
    <p class="endpoint-desc">List screenshots with pagination.</p>
    <p class="endpoint-params">Params: <code>date</code> (optional, YYYY-MM-DD), <code>page</code> (default: 1)</p>
    <pre><code>{
  "screenshots": [
    {
      "id": 1,
      "timestamp": "2026-02-24T10:30:00",
      "date": "2026-02-24",
      "width": 3840,
      "height": 1080,
      "file_size": 125000,
      "similarity": 0.85,
      "storage_type": "live",
      "filepath_thumb": "data/thumbs/..."
    }
  ],
  "total": 500,
  "page": 1,
  "pages": 10
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/screenshots/{id}</span>
    </div>
    <p class="endpoint-desc">Get screenshot details including monitor captures and OCR text.</p>
    <p class="endpoint-params">Params: <code>screenshot_id</code> (path)</p>
    <pre><code>{
  "id": 1,
  "timestamp": "2026-02-24T10:30:00",
  "date": "2026-02-24",
  "width": 3840,
  "height": 1080,
  "file_size": 125000,
  "storage_type": "live",
  "monitors": [
    {
      "id": 1,
      "monitor_name": "DP-1",
      "monitor_index": 0,
      "x": 0, "y": 0, "w": 1920, "h": 1080
    }
  ],
  "ocr_text": "extracted text content..."
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/screenshots/{id}/ocr-words</span>
    </div>
    <p class="endpoint-desc">Get word-level OCR results with bounding boxes. Optionally filter by query.</p>
    <p class="endpoint-params">Params: <code>screenshot_id</code> (path), <code>q</code> (optional query string)</p>
    <pre><code>{
  "screenshot_id": 1,
  "query": "search term",
  "monitors": [
    {
      "monitor_capture_id": 1,
      "monitor_index": 0,
      "monitor_name": "DP-1",
      "words": [
        {
          "word": "search",
          "left_x": 100, "top_y": 200,
          "width": 80, "height": 20,
          "confidence": 0.95
        }
      ]
    }
  ]
}</code></pre>
</div>

<h2 id="api-timeline">API: Timeline &amp; Dates</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/timeline</span>
    </div>
    <p class="endpoint-desc">Get timeline entries for a specific date.</p>
    <p class="endpoint-params">Params: <code>date</code> (required, YYYY-MM-DD)</p>
    <pre><code>{
  "date": "2026-02-24",
  "entries": [ ... ],
  "count": 250
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/dates</span>
    </div>
    <p class="endpoint-desc">Get list of all dates that have screenshot data.</p>
    <pre><code>["2026-02-24", "2026-02-23", "2026-02-22"]</code></pre>
</div>

<h2 id="api-search">API: Search</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/search/text</span>
    </div>
    <p class="endpoint-desc">Full-text search across OCR text using SQLite FTS5.</p>
    <p class="endpoint-params">Params: <code>q</code> (query string), <code>limit</code> (default: 50)</p>
    <pre><code>{
  "query": "search term",
  "results": [
    {
      "screenshot_id": 42,
      "timestamp": "2026-02-24T10:30:00",
      "text_snippet": "...matching text...",
      "rank": -1.5
    }
  ],
  "total": 15
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/search/ai</span>
    </div>
    <p class="endpoint-desc">Semantic search using AI embeddings. Requires <code>[ai] enabled = true</code>.</p>
    <p class="endpoint-params">Params: <code>q</code> (query string), <code>limit</code> (default: 20)</p>
    <pre><code>{
  "query": "what was I working on yesterday",
  "results": [
    {
      "screenshot_id": 42,
      "timestamp": "2026-02-24T10:30:00",
      "similarity": 0.87,
      "text_snippet": "..."
    }
  ],
  "total": 10
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-post">POST</span>
        <span class="endpoint-path">/api/search/ai/chat</span>
    </div>
    <p class="endpoint-desc">AI chat with screenshot context. Uses a two-step process: (1) AI analyzes the query to extract time ranges and keywords, (2) backend searches activity and OCR data, (3) AI answers with context. Returns Server-Sent Events (SSE) stream.</p>
    <p class="endpoint-params">Body: <code>{"query": "...", "history": [{"role": "user"|"assistant", "content": "..."}]}</code></p>
    <pre><code>// Request
POST /api/search/ai/chat
Content-Type: application/json

{
  "query": "What was I reading this morning?",
  "history": []
}

// Response: text/event-stream
data: {"content": "You were reading"}
data: {"content": " an article about..."}
data: [DONE]</code></pre>
</div>

<h2 id="api-activity">API: Activity</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/activity/summary</span>
    </div>
    <p class="endpoint-desc">Get activity summary with app usage, window titles, domains, and timeline.</p>
    <p class="endpoint-params">Params: <code>date</code> (required, YYYY-MM-DD)</p>
    <pre><code>{
  "date": "2026-02-24",
  "total_seconds": 28800,
  "interval": 2,
  "top_apps": [
    {"app_class": "firefox", "app_name": "Firefox", "seconds": 10800, "icon": "firefox"}
  ],
  "top_titles": [
    {"window_title": "GitHub - Mozilla Firefox", "seconds": 3600}
  ],
  "top_domains": [
    {"browser_domain": "github.com", "seconds": 3600}
  ],
  "timeline": [
    {"timestamp": "2026-02-24T09:00:00", "app_class": "firefox", "window_title": "..."}
  ]
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/activity/day-summary</span>
    </div>
    <p class="endpoint-desc">Get detailed day summary with session analysis, optional AI-generated Zeiterfassung, and Message of the Day. When <code>regenerate=true</code>, both the AI summary and MOTD are regenerated.</p>
    <p class="endpoint-params">Params: <code>date</code> (required), <code>regenerate</code> (optional bool)</p>
    <pre><code>{
  "date": "2026-02-24",
  "sessions": [...],
  "metrics": {
    "total_active_seconds": 28800,
    "first_activity": "2026-02-24T07:00:00",
    "last_activity": "2026-02-24T17:30:00",
    "total_break_seconds": 3600,
    "break_count": 3,
    "category_seconds": {"coding": 14400, "browser": 10800, ...}
  },
  "breaks": [...],
  "ai_summary": {
    "summary": "Productive day focused on development...",
    "blocks": [
      {
        "time_range": "07:00-09:30",
        "duration_minutes": 150,
        "label": "ScreenDiary Development",
        "description": "Coding in VSCodium, git operations",
        "category": "coding"
      }
    ]
  },
  "motd": "Guten Morgen! Ein produktiver Tag mit Fokus auf Entwicklung."
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/activity/motd</span>
    </div>
    <p class="endpoint-desc">Get or generate the Message of the Day. Based on the AI day summary (if available). MOTD is also returned as part of the <code>/api/activity/day-summary</code> response. Cached after first generation.</p>
    <pre><code>{
  "motd": "Guten Morgen! Ein produktiver Tag mit viel Entwicklungsarbeit.",
  "date": "2026-02-24"
}</code></pre>
</div>

<h2 id="api-system">API: System</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/stats</span>
    </div>
    <p class="endpoint-desc">Get database and storage statistics.</p>
    <pre><code>{
  "total_screenshots": 15000,
  "live_screenshots": 500,
  "archived_screenshots": 14500,
  "ocr_results": 14800,
  "embeddings": 14000,
  "video_segments": 2800,
  "storage_bytes": 48536870912,
  "storage_gb": 45.2,
  "max_storage_gb": 200,
  "db_size_bytes": 52428800,
  "total_days": 30,
  "first_date": "2026-01-25",
  "last_date": "2026-02-24"
}</code></pre>
</div>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/api/status</span>
    </div>
    <p class="endpoint-desc">Health check endpoint.</p>
    <pre><code>{
  "status": "ok",
  "service": "screendiary-web"
}</code></pre>
</div>

<h2 id="api-images">API: Images</h2>

<div class="endpoint">
    <div class="endpoint-header">
        <span class="method-badge method-get">GET</span>
        <span class="endpoint-path">/screenshots/{id}/image</span>
    </div>
    <p class="endpoint-desc">Serve a screenshot image (full or thumbnail). For archived screenshots, the frame is decoded from the H.265 video segment on the fly.</p>
    <p class="endpoint-params">Params: <code>screenshot_id</code> (path), <code>monitor</code> (default: 0), <code>thumb</code> (default: false)</p>
    <p class="endpoint-params">Response: <code>image/webp</code> or <code>404</code></p>
</div>

<!-- ============================================================ -->
<!-- ARCHITECTURE -->
<!-- ============================================================ -->

<h2 id="architecture">Architecture Overview</h2>

<h3>Component Overview</h3>
<pre><code>┌─────────────────┐     ┌──────────────┐     ┌─────────────┐
│  Capture Daemon  │────▶│   SQLite DB  │◀────│  Web Server  │
│  (asyncio loop)  │     │  (WAL mode)  │     │  (FastAPI)   │
└────────┬────────┘     └──────────────┘     └──────┬──────┘
         │                                          │
    ┌────┴─────┐                              ┌─────┴──────┐
    │ Spectacle │                              │ React SPA  │
    │ Tesseract │                              │ (Vite)     │
    │ FFmpeg    │                              └────────────┘
    │ KWin DBus │
    └──────────┘</code></pre>

<h3>Data Flow</h3>
<ol>
    <li><strong>Capture:</strong> Spectacle takes a screenshot of all monitors</li>
    <li><strong>Split:</strong> Image is split into per-monitor captures</li>
    <li><strong>Dedup:</strong> Structural similarity is compared against previous frame — duplicates are dropped</li>
    <li><strong>Store:</strong> Screenshots saved as WebP, thumbnails generated</li>
    <li><strong>OCR:</strong> Tesseract extracts text + word-level bounding boxes (parallel workers)</li>
    <li><strong>Window:</strong> Active window info captured via KWin DBus scripting + journalctl</li>
    <li><strong>Domain:</strong> Browser domain extracted from Firefox/Chrome history (SQLite immutable mode)</li>
    <li><strong>Embed:</strong> OCR text is embedded via AI API (if enabled)</li>
    <li><strong>Archive:</strong> Old screenshots are encoded into H.265 video segments, originals deleted</li>
</ol>

<h2 id="db-schema">Database Schema</h2>
<p>SQLite database in WAL mode. Schema version: 4. FTS5 for full-text search.</p>

<h3>screenshots</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>timestamp</td><td>TEXT</td><td>ISO 8601 timestamp</td></tr>
        <tr><td>date</td><td>TEXT</td><td>Date string (YYYY-MM-DD)</td></tr>
        <tr><td>width</td><td>INTEGER</td><td>Total capture width</td></tr>
        <tr><td>height</td><td>INTEGER</td><td>Total capture height</td></tr>
        <tr><td>file_size</td><td>INTEGER</td><td>File size in bytes</td></tr>
        <tr><td>similarity</td><td>REAL</td><td>SSIM score vs previous frame</td></tr>
        <tr><td>storage_type</td><td>TEXT</td><td>"live" or "archived"</td></tr>
        <tr><td>segment_path</td><td>TEXT</td><td>Video segment file path (if archived)</td></tr>
        <tr><td>segment_offset_ms</td><td>INTEGER</td><td>Offset within video segment (ms)</td></tr>
        <tr><td>filepath_thumb</td><td>TEXT</td><td>Thumbnail file path</td></tr>
    </tbody>
</table>

<h3>monitor_captures</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>screenshot_id</td><td>INTEGER FK</td><td>References screenshots(id)</td></tr>
        <tr><td>monitor_name</td><td>TEXT</td><td>Monitor output name (e.g. "DP-1")</td></tr>
        <tr><td>monitor_index</td><td>INTEGER</td><td>Monitor index (0-based)</td></tr>
        <tr><td>filepath</td><td>TEXT</td><td>Per-monitor image path</td></tr>
        <tr><td>segment_path</td><td>TEXT</td><td>Video segment path (if archived)</td></tr>
        <tr><td>segment_offset_ms</td><td>INTEGER</td><td>Offset in video segment</td></tr>
        <tr><td>x, y, w, h</td><td>INTEGER</td><td>Monitor position and dimensions</td></tr>
    </tbody>
</table>

<h3>ocr_results</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>screenshot_id</td><td>INTEGER FK</td><td>References screenshots(id)</td></tr>
        <tr><td>monitor_capture_id</td><td>INTEGER FK</td><td>References monitor_captures(id)</td></tr>
        <tr><td>text</td><td>TEXT</td><td>Full extracted text</td></tr>
        <tr><td>language</td><td>TEXT</td><td>Detected language</td></tr>
        <tr><td>confidence</td><td>REAL</td><td>Average OCR confidence</td></tr>
    </tbody>
</table>

<h3>ocr_words</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>ocr_result_id</td><td>INTEGER FK</td><td>References ocr_results(id)</td></tr>
        <tr><td>monitor_capture_id</td><td>INTEGER FK</td><td>References monitor_captures(id)</td></tr>
        <tr><td>word</td><td>TEXT</td><td>Individual word</td></tr>
        <tr><td>left_x, top_y</td><td>INTEGER</td><td>Bounding box position</td></tr>
        <tr><td>width, height</td><td>INTEGER</td><td>Bounding box size</td></tr>
        <tr><td>confidence</td><td>REAL</td><td>Word-level confidence</td></tr>
    </tbody>
</table>

<h3>embeddings</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>screenshot_id</td><td>INTEGER FK</td><td>References screenshots(id)</td></tr>
        <tr><td>vector</td><td>BLOB</td><td>Embedding vector (binary)</td></tr>
        <tr><td>model</td><td>TEXT</td><td>Model used for embedding</td></tr>
        <tr><td>dimensions</td><td>INTEGER</td><td>Vector dimensionality</td></tr>
        <tr><td>text_hash</td><td>TEXT</td><td>Hash of source text (for dedup)</td></tr>
    </tbody>
</table>

<h3>video_segments</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>date</td><td>TEXT</td><td>Date of segment</td></tr>
        <tr><td>monitor_index</td><td>INTEGER</td><td>Monitor index</td></tr>
        <tr><td>filepath</td><td>TEXT</td><td>Video file path</td></tr>
        <tr><td>start_time</td><td>TEXT</td><td>First frame timestamp</td></tr>
        <tr><td>end_time</td><td>TEXT</td><td>Last frame timestamp</td></tr>
        <tr><td>frame_count</td><td>INTEGER</td><td>Number of frames</td></tr>
        <tr><td>file_size</td><td>INTEGER</td><td>Segment file size</td></tr>
    </tbody>
</table>

<h3>window_events</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>screenshot_id</td><td>INTEGER FK</td><td>References screenshots(id)</td></tr>
        <tr><td>timestamp</td><td>TEXT</td><td>Event timestamp</td></tr>
        <tr><td>app_class</td><td>TEXT</td><td>Application class (e.g. "firefox")</td></tr>
        <tr><td>app_name</td><td>TEXT</td><td>Application display name</td></tr>
        <tr><td>window_title</td><td>TEXT</td><td>Active window title</td></tr>
        <tr><td>desktop_file</td><td>TEXT</td><td>.desktop file path</td></tr>
        <tr><td>pid</td><td>INTEGER</td><td>Process ID</td></tr>
        <tr><td>browser_domain</td><td>TEXT</td><td>Extracted domain (browsers only)</td></tr>
    </tbody>
</table>

<h3>activity_day_summaries</h3>
<table class="schema-table">
    <thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>id</td><td>INTEGER PK</td><td>Auto-incrementing ID</td></tr>
        <tr><td>date</td><td>TEXT UNIQUE</td><td>Summary date</td></tr>
        <tr><td>summary_text</td><td>TEXT</td><td>AI-generated summary</td></tr>
        <tr><td>session_labels</td><td>TEXT</td><td>Session label data</td></tr>
        <tr><td>model</td><td>TEXT</td><td>AI model used</td></tr>
        <tr><td>created_at</td><td>TEXT</td><td>Creation timestamp</td></tr>
        <tr><td>event_count</td><td>INTEGER</td><td>Number of events summarized</td></tr>
    </tbody>
</table>

<h3>ocr_fts (FTS5 Virtual Table)</h3>
<p>Full-text search index on <code>ocr_results.text</code>. Tokenizer: <code>unicode61 remove_diacritics 2</code>. Automatically maintained by INSERT/DELETE triggers.</p>

<h2 id="capture-pipeline">Capture Pipeline</h2>

<p>The capture daemon runs an asyncio event loop with the following cycle (every <code>[capture] interval</code> seconds):</p>

<pre><code>1. Spectacle screenshot (all monitors) via asyncio subprocess
2. Split into per-monitor images
3. SSIM deduplication against previous frame
4. Save WebP images + thumbnails
5. Insert screenshot + monitor_captures into DB
6. OCR processing (parallel workers via ProcessPoolExecutor)
   ├── Extract full text → ocr_results
   └── Extract word bounding boxes → ocr_words
7. Window tracking (KWin DBus script via journalctl)
   └── Insert into window_events
8. Browser domain extraction (Firefox/Chrome history SQLite)
9. AI embedding generation (if enabled)
   └── Insert into embeddings
10. Video archiving check (if screenshots older than archive_after_minutes)
    ├── Encode frames to H.265 segment via FFmpeg
    ├── Update storage_type, segment_path, segment_offset_ms
    └── Delete original image files</code></pre>

<h2 id="storage-archiving">Storage &amp; Archiving</h2>

<h3>Storage Layout</h3>
<pre><code>data/
├── screendiary.db          # SQLite database
├── live/                   # Live screenshot images
│   └── YYYY-MM-DD/
│       ├── HH-MM-SS_mon0.webp
│       ├── HH-MM-SS_mon1.webp
│       └── ...
├── thumbs/                 # Thumbnails
│   └── YYYY-MM-DD/
│       └── HH-MM-SS_thumb.webp
└── segments/               # H.265 video archives
    └── YYYY-MM-DD/
        ├── mon0_0000.mp4
        ├── mon0_0001.mp4
        └── ...</code></pre>

<h3>Archiving Process</h3>
<ul>
    <li>Screenshots older than <code>archive_after_minutes</code> are grouped by monitor and time window</li>
    <li>Each group is encoded as an H.265 video segment (<code>segment_duration_minutes</code> long)</li>
    <li>FFmpeg encodes with CRF <code>h265_crf</code> and preset <code>h265_preset</code></li>
    <li>Original image files are deleted after successful archiving</li>
    <li>DB records are updated with <code>storage_type = "archived"</code> and segment offset info</li>
    <li>Playback: frames are decoded on demand from video segments using FFmpeg</li>
    <li>A frame cache (<code>frame_cache_size</code>) avoids repeated decoding</li>
</ul>

<!-- ============================================================ -->
<!-- TROUBLESHOOTING -->
<!-- ============================================================ -->

<h2 id="troubleshooting">Troubleshooting</h2>

<h3>Missing Dependencies</h3>
<p>If you see errors about missing commands, install the required system packages:</p>
<pre><code># Arch Linux
sudo pacman -S tesseract tesseract-data-eng tesseract-data-deu spectacle ffmpeg

# Check Tesseract languages
tesseract --list-langs</code></pre>

<h3>No Monitors Detected</h3>
<p>Spectacle may fail on non-KDE or X11 sessions. ScreenDiary requires KDE Plasma 6 on Wayland. Check:</p>
<pre><code>echo $XDG_SESSION_TYPE   # Should be "wayland"
echo $DESKTOP_SESSION     # Should be "plasma"</code></pre>

<h3>Spectacle Conflicts</h3>
<p>If Spectacle is already running (e.g. from a keyboard shortcut), the capture daemon may fail. Ensure no other Spectacle instances are active:</p>
<pre><code>killall spectacle
uv run screendiary capture</code></pre>

<h3>Browser Domain Detection</h3>
<p>Domain extraction reads browser history databases in SQLite immutable mode. This requires:</p>
<ul>
    <li><strong>Firefox:</strong> History is in <code>~/.mozilla/firefox/&lt;profile&gt;/places.sqlite</code></li>
    <li><strong>Chrome:</strong> History is in <code>~/.config/google-chrome/Default/History</code></li>
    <li>The browser must be running — history is read from the active database</li>
</ul>

<h3>AI Features Not Working</h3>
<ul>
    <li>Ensure <code>[ai] enabled = true</code> in config</li>
    <li>Verify <code>api_base</code> is reachable: <code>curl $API_BASE/models</code></li>
    <li>Check that the embedding and chat models are available on your API</li>
    <li>Review logs for API errors: <code>uv run screendiary logs</code></li>
</ul>

<h3>Frontend Not Loading</h3>
<pre><code># Rebuild the frontend
uv run screendiary build

# Check if dist exists
ls src/screendiary/web/frontend_dist/</code></pre>

<h3>Signal Control</h3>
<p>Manually pause/resume the capture daemon:</p>
<pre><code># Pause
systemctl --user kill --signal=SIGUSR1 screendiary-capture.service

# Resume
systemctl --user kill --signal=SIGUSR2 screendiary-capture.service</code></pre>

<h3>Viewing Logs</h3>
<pre><code># All services
uv run screendiary logs

# Specific service
journalctl --user -u screendiary-capture.service -f
journalctl --user -u screendiary-web.service -f
journalctl --user -u screendiary-tray.service -f</code></pre>

<h3>Database Debugging</h3>
<pre><code># Open the database
sqlite3 data/screendiary.db

-- Check schema version
SELECT value FROM app_meta WHERE key = 'schema_version';

-- Count screenshots by type
SELECT storage_type, COUNT(*) FROM screenshots GROUP BY storage_type;

-- Check storage usage
SELECT SUM(file_size) / 1024.0 / 1024.0 / 1024.0 AS gb FROM video_segments;

-- Recent window events
SELECT timestamp, app_name, window_title FROM window_events ORDER BY timestamp DESC LIMIT 10;

-- FTS search
SELECT * FROM ocr_fts WHERE ocr_fts MATCH 'search term' LIMIT 10;</code></pre>

<!-- Footer -->
<footer class="footer">
    <p>Developed by <a href="https://luxcode.io" target="_blank">LUXCODE</a></p>
</footer>

</div>
</main>

<script src="js/docs.js"></script>

</body>
</html>
